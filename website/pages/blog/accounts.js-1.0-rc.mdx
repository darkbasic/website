---
title: Announcing Accounts.js 1.0 Release Candidate
tags: [accounts-js, graphql-modules, graphql]
authors: [niccolo]
date: 2023-11-27
description:
  Introducing Accounts.js 1.0 Release Candidate, an end to end authentication and accounts management solution.
image: /blog-assets/accounts.js-1.0-rc/accounts-logo-wide.png
thumbnail: /blog-assets/accounts.js-1.0-rc/accounts-logo-squared.png
---

The first release candidate of [Accounts.js](https://www.accountsjs.com/) 1.0 has finally been released!

This is the culmination of a long process of rearchitecting the whole framework, which is finally a first class [graphql-modules](https://the-guild.dev/graphql/modules) citizen and supports latest graphql 16 and [graphql-tools](https://the-guild.dev/graphql/tools) 10 as well as any modern GraphQL server including Apollo Server 4 and [GraphQL Yoga](https://the-guild.dev/graphql/yoga-server) 5.

## What Is Accounts.js

The `@accounts` suite of packages aims to provide an end to end authentication and accounts management solution, with a simple way to start while preserving options for configuration. These packages provide OAuth support for popular providers such as Instagram or Twitter, two factor authentication, password based accounts along with recovery options and customizable account creation and validation.

Three pieces need to be configured to use accounts-js in your application:

1.  **Transports**:
    Since accounts-js is very flexible, it can be used with multiple transports. For now we provide packages for both GraphQL and REST.

2.  **Databases**:
    We provide a native mongo integration. We also have MikroORM and Typeorm integrations which will let you use accounts-js with any kind of databases. Optionally Redis can be used to store the sessions and you can also provide any custom database adapter that will work with existing authentication strategies by simply implementing the `DatabaseInterface`.

3.  **Strategies**:
    You can use multiple strategies to let your users access to your app. For now we support authentication via the email/username and password combination, magic link and oauth.

**TIP**: Accounts.js is a **full stack** solution, so in addition it also provides a full set of packages to seamlessly implement your chosen authentication workflow in your **client** as well!

## The New Architecture

In Accounts.js 1.0 we use graphql-modules to compose the authentication framework, automatically piecing together your preferred database adapter(s) with the authentication service(s) of your choice (password, oauth, etc).
We support both GraphQL and REST transports: for the former graphql-modules will automatically provide you the schema based on the modules that you're using while for the latter it will simply provide dependency injection across the various modules to piece them together.

```ts
const app = createApplication({
  modules: [
    createAccountsCoreModule({ tokenSecret: 'secret' }),
    createAccountsPasswordModule({
      requireEmailVerification: true,
      sendVerificationEmailAfterSignup: true,
    }),
    createAccountsMongoModule({ dbConn }),
  ],
  schemaBuilder: buildSchema({ typeDefs, resolvers }),
```

If your application already makes use of graphql-modules all you need to do is adding the accounts.js modules of choice to your own, otherwise it's only a matter of providing your resolvers and type definitions to the `buildSchema` function.

```ts
// GraphQL Yoga 5
const yoga = createYoga({
  plugins: [useGraphQLModules(app)],
  context: (ctx) => context(ctx, { createOperationController }),
});
createServer(yoga).listen();

// Apollo Server 4
const apollo = new ApolloServer({
  gateway: app.createApolloGateway(),
});
startStandaloneServer(apollo, {
  context: (ctx) => context(ctx, { createOperationController }),
});
```

At this point whatever is your GraphQL server of choice your authenticated application is just a few lines of code away.

> But what if all I care is REST?

Use the graphql-modules injector to retrieve the `AccountsServer` instance and feed it to `@accounts/rest-express`!

```ts
const controller = app.createOperationController({
  context: {},
});
const accountsServer = controller.injector.get(AccountsServer);
expressApp.use(accountsExpress(accountsServer));
```

Alternatively if you don't want to use graphql-modules at all you can still manually instantiate the providers (there is an example in the [examples folder](https://github.com/accounts-js/accounts/tree/master/examples) if you are interested).

## The New MikroORM Database Adapter

The second big change of Accounts.js 1.0 is the release of the brand new [MikroORM](https://mikro-orm.io/) database adapter. MikroORM is a TypeScript ORM for Node.js based on Data Mapper, Unit of Work and Identity Map patterns. It is also very well written and actively developed.
Today also marks the release of the v6 of MikroORM, which incorporates [my recent work](https://github.com/mikro-orm/mikro-orm/pull/4321) to automatically batch references and collections and retrieve them via dataloaders firing a single query. This is especially useful with the GraphQL transport since it automatically solves its notorious N+1 problem without you even noticing it. More informations [here](https://mikro-orm.io/docs/dataloaders).

```ts
@Entity()
export class User extends AccountsUser {
  @Property()
  firstName: string;

  @Property({ nullable: true })
  lastName?: string;

  constructor({ firstName, lastName, ...otherProps }: CtorArgs) {
    super(otherProps);
    this.firstName = firstName;
    if (lastName) {
      this.lastName = lastName;
    }
  }
}
```

The Accounts.js MikroORM database adapter can be backed by your database of choice (PostgreSQL, MySQL, MariaDB, SQLite, MongoDB) and won't force you into any existing entity schema: use the existing entities or provide your own, but make sure to extend the base ones so that authentication can occur.

```ts
entities: [
  User,
  getUserSchema({ AccountsUser, abstract: true }),
  getEmailSchema({ UserEntity: User }),
  getServiceSchema({ UserEntity: User }),
  getSessionSchema({ UserEntity: User }),
],
```

Under the hood it makes use of MikroORM's [EntitySchema](https://mikro-orm.io/docs/entity-schema) so you will have to provide the schema for the base entities as well.

## Breaking changes

`@accounts/boost` has been removed. It was no longer deemed necessary because the new graphql-modules architecture already allows you to plug and play the various modules. For example instead of providing an existing database connection you can easily let `@accounts/module-mongo` create a new one for you:

```ts
const app = createApplication({
  modules: [
    [...],
    // If you don't provide dbConn it will automatically
    // create a new one, but the module needs to be awaited.
    await createAccountsMongoModule(),
```

`@accounts/graphql-api` has been moved into the following packages:

*   `@accounts/module-core`
*   `@accounts/module-magic-link`
*   `@accounts/module-mikro-orm`
*   `@accounts/module-mongo`
*   `@accounts/module-password`
*   `@accounts/module-typeorm`

Use these packages to piece together your desired authentication workflow along with your preferred database adapter. Despite the big changes under the hood I strived to keep the public API mostly the same so migrating to 1.0 shouldn't be a huge effort.

## What's new

*   We switched from pnpm to yarn 4.
*   We now return code 401 unmasked errors when unauthorized.
*   Added the `requireEmailVerification` option to require the user to verify the email in order to be able to authenticate.
*   You can now enable both `ambiguousErrorMessages` and `enableAutologin` if `requireEmailVerification` is disabled.
*   `@accounts/password` provides express endpoints to verify the email or reset the password whenever the user clicks on the links received via email.
*   `@accounts/rest-express` now validates its inputs via express-validator.
*   The examples now use graphql-yoga v5 instead of the old apollo-server 2.
*   A new `@apollo/server` v4 example has been added.
*   A basic graphql-http example has been added.
*   A MikroORM example has been added.
*   The accounts-microservice example has been rewritten from scratch to use modern graphql-tools.
*   Docs have been refactored to use `docusaurus-plugin-typedoc-api` instead of `scripts/generate-api-docs.ts`.
*   New and much improved CI release workflow.
*   Basic support for running tests from vscode.
*   Upgraded `graphql-modules` to v3 alpha
*   Upgraded `@graphql-tools/merge` to v9
*   Upgraded `@graphql-tools/schema` to v10
*   Upgraded `@graphql-tools/utils` to v10
*   Upgraded `graphql` to v16
*   Upgraded `typeorm` to 0.3.17
*   Upgraded `@apollo/client` to 3.8
*   Upgraded `@graphql-codegen` to v5
*   Upgraded `mongodb` to v6
*   Upgraded `ioredis` to v5
*   Upgraded `jsonwebtoken` to v9
*   Upgraded `lodash` to 4.17
*   Upgraded `pg` to 8.11
*   Upgraded `request-ip` to 3.3
*   Upgraded `oauth` to 0.10
*   Upgraded `node-fetch` to 2.7
*   Upgraded `express` to 4.18
*   Upgraded `emittery` to 0.13
*   Upgraded `@levminer/speakeasy` to 1.4
*   Upgraded `@graphql-tools/delegate` to v10
*   Upgraded `@graphql-tools/stitch` to v9
*   Upgraded `@graphql-tools/wrap` to v10
*   Upgraded `mongoose` to v8
*   Upgraded `react` to 18.2
*   Upgraded `jest` to 29
*   Upgraded `typescript` to 5.3
*   Upgraded `eslint` to v8
*   Upgraded `prettier` to v3
*   Upgraded `@apollo/server` to 4.9
*   Upgraded `docusaurus` to v3

## What's left before 1.0 stable

OAuth authentication, while working, surely deserves some love. While REST endpoints for OAuth should be functional there are no mutations nor resolvers yet, meaning that you can't use it with the GraphQL transport. I'd also like to go through the OAuth code and write some examples. `@accounts/oauth-instagram` in particular still relies upon the deprecated `request` package and should be updated. Other popular OAuth providers like Facebook still need to be added (but PRs exist).

Before 1.0 stable gets released I plan to at least get the existing providers in a better shape, together with examples and the relevant GraphQL schema.

## Post 1.0

I'd like to create a new `@accounts/phone` authentication service which lets you authenticate via SMS OTPs. That would be especially useful in react-native applications where you could automatically read the sms and automate the authentication process.

Currently Accounts.js bundles CommonJS code. While CommonJS can be imported in both CommonJS and ESM applications that would rule out Deno/Bun support. For the same reason we cannot use a wrapper either: while that would allow to use ESM imports it wouldn't be real ESM and thus won't be compatible. The remaning alternatives are pure ESM and dual packages. While several library authors opted for the former because of [dual package hazard](https://nodejs.org/api/packages.html#packages_dual_package_hazard) concerns I weight the benefits differently. While dual package hazards are real the whole GraphQL echosystem relies on dual packages thus using `instanceof` is already an hazard. These authors suggest to use `async imports` to import their pure ESM libraries in commonjs projects, which exposes everyone to the very same hazard (not even considering the fact that this is only viable in async contexts). That basically goes against the reason why they decided to bundle pure esm in the first place. I personally think that it's still too early to target pure esm and dual package is the lesser evil so I'm leaning towards that for future releases, but I'm ready to change my mind if you provide me enough arguments.

I'd also like to implement some form of accounts linking, where users could link their existing account with a different authentication service (for example password and oauth).

I would like to a extend Multi Factor Authentication outside of the password service, baking it into the core of accounts.js so that any authentication service can take advantage of it.

If future major versions of Accounts.js will introduce breaking changes to the database structure I would like to provide migrations directly via the `@accounts/mikro-orm` package.

Last but not the least I would like to bake in cookies authentication. Not only that would fare better against XSS, it would also allow server side rendering and thus enable the usage of frameworks like Next.js. Alternative storage methods would remain available for those using native applications.

At the end of the day 1.0 is just a number and what I really want is to provide stable APIs via semantic versioning.

Accounts.js is an open source project and we welcome your [contributions](https://github.com/accounts-js/accounts)!
